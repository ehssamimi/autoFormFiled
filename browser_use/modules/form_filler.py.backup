"""
Form Filler Core Module
Main FormFiller class that orchestrates form filling
"""

import json
import os
import re
from typing import Dict, List, Optional, Any, Set
from pathlib import Path

from .text_filler import TextFieldFiller
from .select_filler import SelectFieldFiller
from .date_picker_filler import DatePickerFiller
from .file_upload_filler import FileUploadFiller
from .radio_filler import RadioFieldFiller
from .checkbox_filler import CheckboxFieldFiller
from .field_detector import FieldDetector
from .utils import resolve_file_path


class FormFiller:
    """
    Main class for automating form filling on web pages
    """
    
    def __init__(self, config_path: str = "config.json", page=None):
        """
        Initialize FormFiller with configuration file
        
        Args:
            config_path: Path to JSON configuration file
            page: Playwright page object (optional, can be set later)
        """
        self.config_path = config_path
        self.config = self._load_config()
        self.page = page
    
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration from JSON file"""
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            print(f"[ERROR] Config file not found: {self.config_path}")
            raise
        except json.JSONDecodeError:
            print(f"[ERROR] Invalid JSON in config file: {self.config_path}")
            raise
    
    async def _handle_cookie_consent(self) -> Optional[bool]:
        """
        Handle cookie consent popup
        Returns:
            True if cookie was found and handled
            False if cookie exists but couldn't be handled
            None if cookie doesn't exist on page
        """
        if not self.page:
            return None
        
        try:
            # Quick check: wait for cookie wrapper with short timeout
            try:
                await self.page.wait_for_selector(
                    '[id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"]',
                    timeout=1500
                )
            except Exception:
                # No cookie wrapper found - cookie doesn't exist
                return None
            
            # Cookie wrapper exists, check for buttons
            cookie_selectors = [
                'button:has-text("Alle akzeptieren")',
                'button:has-text("Accept all")',
                'button:has-text("Akzeptieren")',
                'button:has-text("Accept")',
                '[id*="accept"], [class*="accept"]',
                '[id*="cookie"] button',
                '[class*="cookie"] button',
                'button[aria-label*="accept" i]',
                'button[aria-label*="akzeptieren" i]',
                '.cookie-consent button',
                '#cookie-consent button'
            ]
            
            for selector in cookie_selectors:
                try:
                    button = self.page.locator(selector).first
                    if await button.count() > 0:
                        is_visible = await button.is_visible()
                        if is_visible:
                            await button.scroll_into_view_if_needed()
                            await button.click()
                            print('[OK] Cookie consent accepted')
                            await self.page.wait_for_timeout(1000)
                            return True
                except Exception:
                    continue
            
            # Try close button
            close_selectors = [
                'button[aria-label*="close" i]',
                'button[aria-label*="schließen" i]',
                '.close, .modal-close, [class*="close"]',
                'button:has-text("×")',
                'button:has-text("✕")'
            ]
            
            for selector in close_selectors:
                try:
                    button = self.page.locator(selector).first
                    if await button.count() > 0:
                        is_visible = await button.is_visible()
                        if is_visible:
                            await button.scroll_into_view_if_needed()
                            await button.click()
                            print('[OK] Cookie popup closed')
                            await self.page.wait_for_timeout(1000)
                            return True
                except Exception:
                    continue
            
            # Cookie wrapper exists but no button found
            return False
        except Exception as e:
            print(f'[WARNING] Cookie consent check error: {str(e)}')
            return None
    
    async def _get_form_fields_in_order(self) -> List:
        """
        Get all form fields sorted by position (top to bottom)
        """
        if not self.page:
            return []
        
        try:
            # Get all form elements
            fields = await self.page.evaluate("""
                () => {
                    const allFields = [];
                    const selectors = [
                        'input:not([type="hidden"]):not([type="submit"]):not([type="button"])',
                        'select',
                        'textarea',
                        '[role="textbox"]',
                        '[role="combobox"]',
                        '[role="listbox"]',
                        '[contenteditable="true"]'
                    ];
                    
                    selectors.forEach(sel => {
                        document.querySelectorAll(sel).forEach(field => {
                            const style = window.getComputedStyle(field);
                            const isVisible = (
                                style.display !== 'none' &&
                                style.visibility !== 'hidden' &&
                                style.opacity !== '0' &&
                                field.offsetWidth > 0 &&
                                field.offsetHeight > 0 &&
                                !field.disabled &&
                                !field.readOnly
                            );
                            
                            if (isVisible) {
                                const rect = field.getBoundingClientRect();
                                // For select elements, ensure we get the right type
                                let fieldType = field.type || field.tagName.toLowerCase();
                                if (field.tagName.toLowerCase() === 'select') {
                                    fieldType = 'select';
                                }
                                
                                allFields.push({
                                    name: field.name || '',
                                    id: field.id || '',
                                    type: fieldType,
                                    x: rect.left,
                                    y: rect.top,
                                    selector: sel
                                });
                            }
                        });
                    });
                    
                    // IMPORTANT: Also find file inputs even if they're hidden
                    // File inputs are often hidden and shown via a button/label
                    document.querySelectorAll('input[type="file"]').forEach(field => {
                        // Check if we already added this field
                        const alreadyAdded = allFields.some(f => 
                            f.name === (field.name || '') && 
                            f.id === (field.id || '') && 
                            f.type === 'file'
                        );
                        
                        if (!alreadyAdded) {
                            // Try to find associated label or button to get position
                            let rect = { left: 0, top: 0 };
                            let label = null;
                            
                            // Try to find label by 'for' attribute
                            if (field.id) {
                                label = document.querySelector(`label[for="${field.id}"]`);
                            }
                            
                            // If no label by 'for', try to find parent label
                            if (!label) {
                                label = field.closest('label');
                            }
                            
                            // If label found, use its position
                            if (label) {
                                rect = label.getBoundingClientRect();
                            } else {
                                // Try to find button or span near the file input
                                const parent = field.parentElement;
                                if (parent) {
                                    const button = parent.querySelector('button');
                                    if (button) {
                                        rect = button.getBoundingClientRect();
                                    } else {
                                        rect = parent.getBoundingClientRect();
                                    }
                                }
                            }
                            
                            allFields.push({
                                name: field.name || '',
                                id: field.id || '',
                                type: 'file',
                                x: rect.left,
                                y: rect.top,
                                selector: 'input[type="file"]'
                            });
                        }
                    });
                    
                    // Sort by position (top to bottom, left to right)
                    allFields.sort((a, b) => {
                        if (Math.abs(a.y - b.y) < 10) {
                            return a.x - b.x; // Same row, sort by x
                        }
                        return a.y - b.y; // Sort by y
                    });
                    
                    return allFields;
                }
            """)
            
            
            # Convert to locators - Process ALL fields in order (not separate passes)
            field_locators = []
            processed_names = set()  # Track processed field names to avoid duplicates
            processed_positions = set()  # Track processed positions to avoid duplicates
            
            # If no select fields found in evaluation, add them from direct search
            select_fields_in_eval = [f for f in fields if f.get('type', '').lower() == 'select']
            if len(select_fields_in_eval) == 0:
                try:
                    all_selects_direct = await self.page.locator('select').all()
                    for sel in all_selects_direct:
                        try:
                            is_visible = await sel.is_visible()
                            if is_visible:
                                sel_name = await sel.get_attribute('name')
                                sel_id = await sel.get_attribute('id')
                                sel_rect = await sel.bounding_box()
                                if sel_rect:
                                    # Add to fields list in correct position
                                    fields.append({
                                        'name': sel_name or '',
                                        'id': sel_id or '',
                                        'type': 'select',
                                        'x': sel_rect['left'],
                                        'y': sel_rect['top'],
                                        'selector': 'select'
                                    })
                                    # Re-sort fields by position
                                    fields.sort(key=lambda f: (f.get('y', 0), f.get('x', 0)))
                        except Exception:
                            continue
                except Exception:
                    pass
            
            # Process all fields in order (not separate passes)
            for field in fields:
                # Skip if we already processed a field with this name (prefer visible over hidden)
                if field.get('name') and field['name'] in processed_names:
                    continue
                
                # Skip if position is already processed
                pos_key = f"{field.get('x', 0)}_{field.get('y', 0)}"
                if pos_key in processed_positions:
                    continue
                
                selectors_to_try = []
                field_type = field.get('type', '').lower()
                
                # Skip hidden inputs completely (except file inputs which are often hidden)
                if field_type == 'hidden':
                    continue
                
                # For file inputs, always include them even if they appear hidden
                # (they're often hidden and shown via button/label)
                if field_type == 'file':
                    if field.get('id'):
                        selectors_to_try.append(f'input[type="file"]#{field["id"]}')
                    if field.get('name'):
                        selectors_to_try.append(f'input[type="file"][name="{field["name"]}"]')
                    # Also try to find by label
                    if field.get('id'):
                        selectors_to_try.append(f'label[for="{field["id"]}"] input[type="file"]')
                
                # For select fields, prioritize select element over hidden input
                elif field_type == 'select':
                    if field.get('id'):
                        selectors_to_try.append(f'select#{field["id"]}')
                    if field.get('name'):
                        selectors_to_try.append(f'select[name="{field["name"]}"]')
                    # Fallback: find all selects and match by position
                    selectors_to_try.append('select_by_position')
                else:
                    # For other fields (text, email, date, etc.), try id, name, then type
                    if field.get('id'):
                        selectors_to_try.append(f'#{field["id"]}')
                    if field.get('name'):
                        # Exclude hidden inputs
                        selectors_to_try.append(f'[name="{field["name"]}"]:not([type="hidden"])')
                    if field.get('type') and field_type not in ['hidden', 'submit', 'button', 'file']:
                        selectors_to_try.append(f'{field["type"]}:not([type="hidden"])')
                
                # Try to find the field
                found = False
                for selector in selectors_to_try:
                    try:
                        if selector == 'select_by_position':
                            # For select fallback, find all selects and match by position
                            all_selects = await self.page.locator('select').all()
                            for sel in all_selects:
                                try:
                                    sel_rect = await sel.bounding_box()
                                    if sel_rect:
                                        # Check if position is close (within 50px)
                                        y_diff = abs(sel_rect['y'] - field.get('y', 0))
                                        x_diff = abs(sel_rect['x'] - field.get('x', 0))
                                        if y_diff < 50 and x_diff < 50:
                                            is_visible = await sel.is_visible()
                                            if is_visible:
                                                field_locators.append(sel)
                                                if field.get('name'):
                                                    processed_names.add(field['name'])
                                                sel_name = await sel.get_attribute('name')
                                                if sel_name:
                                                    processed_names.add(sel_name)
                                                processed_positions.add(pos_key)
                                                found = True
                                                break
                                except Exception:
                                    continue
                            if found:
                                break
                        else:
                            locator = self.page.locator(selector).first
                            if await locator.count() > 0:
                                # Double check it's not hidden
                                is_hidden = await locator.evaluate("""
                                    (el) => {
                                        return el.type === 'hidden' || 
                                               el.style.display === 'none' || 
                                               el.style.visibility === 'hidden' ||
                                               el.offsetWidth === 0 ||
                                               el.offsetHeight === 0;
                                    }
                                """)
                                
                                # For file inputs, skip the is_hidden check (they're often hidden)
                                if field_type == 'file':
                                    field_locators.append(locator)
                                    if field.get('name'):
                                        processed_names.add(field['name'])
                                    processed_positions.add(pos_key)
                                    found = True
                                    break
                                elif not is_hidden:
                                    is_visible = await locator.is_visible()
                                    if is_visible:
                                        field_locators.append(locator)
                                        if field.get('name'):
                                            processed_names.add(field['name'])
                                        processed_positions.add(pos_key)
                                        found = True
                                        break
                    except Exception:
                        continue
                
                # If not found with specific selectors, try generic selector but exclude hidden
                if not found and field['name'] and field_type != 'hidden':
                    try:
                        # Try to find by name but exclude hidden and prefer visible elements
                        all_with_name = await self.page.locator(f'[name="{field["name"]}"]').all()
                        for elem in all_with_name:
                            elem_type = await elem.evaluate("""
                                (el) => {
                                    if (el.type === 'hidden') return 'hidden';
                                    if (el.tagName === 'SELECT') return 'select';
                                    return el.type || el.tagName.toLowerCase();
                                }
                            """)
                            
                            if elem_type != 'hidden':
                                is_visible = await elem.is_visible()
                                if is_visible:
                                    field_locators.append(elem)
                                    processed_names.add(field['name'])
                                    processed_positions.add(pos_key)
                                    found = True
                                    break
                    except Exception:
                        pass
            
            return field_locators
        except Exception as e:
            print(f'[WARNING] Error getting form fields: {str(e)}')
            return []
    
    async def _get_field_info(self, locator) -> Dict[str, Any]:
        """
        Get field metadata
        """
        try:
            field_type = await FieldDetector.detect_type(locator)
            name = await locator.get_attribute('name')
            field_id = await locator.get_attribute('id')
            placeholder = await locator.get_attribute('placeholder')
            label = await FieldDetector.get_label(locator)
            
            # For file inputs, also get display and visibility
            display = None
            visibility = None
            if field_type == 'file':
                try:
                    display = await locator.evaluate("""
                        (input) => {
                            return window.getComputedStyle(input).display;
                        }
                    """)
                    visibility = await locator.evaluate("""
                        (input) => {
                            return window.getComputedStyle(input).visibility;
                        }
                    """)
                except Exception:
                    pass
            
            return {
                'type': field_type,
                'name': name,
                'id': field_id,
                'placeholder': placeholder,
                'label': label,
                'display': display,
                'visibility': visibility
            }
        except Exception:
            return {'type': 'unknown'}
    
    async def _is_field_filled(self, locator, field_info: Dict) -> bool:
        """
        Check if a field is already filled/has a value
        """
        try:
            field_type = field_info.get('type', 'unknown')
            
            if field_type == 'text' or field_type == 'email' or field_type == 'tel' or field_type == 'textarea':
                try:
                    value = await locator.input_value()
                    return value and value.strip() != ''
                except Exception:
                    return False
            
            elif field_type == 'select':
                try:
                    selected_value = await locator.input_value()
                    return selected_value and selected_value.strip() != '' and selected_value != '0'
                except Exception:
                    return False
            
            elif field_type == 'radio':
                try:
                    name = field_info.get('name')
                    if name:
                        # Check if any radio in the group is checked
                        checked_radio = await self.page.locator(f'input[type="radio"][name="{name}"]:checked').count()
                        return checked_radio > 0
                except Exception:
                    return False
            
            elif field_type == 'checkbox':
                try:
                    is_checked = await locator.is_checked()
                    return is_checked
                except Exception:
                    return False
            
            elif field_type == 'file':
                # For file inputs, check if files are selected
                try:
                    # First check if the file input has files
                    file_count = await locator.evaluate("""
                        (input) => {
                            return input.files ? input.files.length : 0;
                        }
                    """)
                    if file_count > 0:
                        return True
                    
                    # Also check if there's a visible indicator (like file name shown in a text input or span)
                    # This is for custom file uploads where the file input is hidden
                    field_id = field_info.get('id')
                    if field_id:
                        # Check if there's a text input or span showing the file name
                        try:
                            # Look for text input with same id pattern or nearby
                            text_input = self.page.locator(f'input[type="text"][id*="{field_id}"]').first
                            if await text_input.count() > 0:
                                text_value = await text_input.input_value()
                                if text_value and text_value.strip():
                                    return True
                        except Exception:
                            pass
                    
                    return False
                except Exception:
                    return False
            
            return False
        except Exception:
            return False
    
    async def _get_field_options(self, locator, field_type: str) -> List[Dict[str, str]]:
        """
        Get available options for select or radio fields
        """
        options = []
        try:
            if field_type == 'select':
                options = await SelectFieldFiller._get_available_options(locator)
            elif field_type == 'radio':
                # Get all radio buttons with the same name
                name = await locator.get_attribute('name')
                if name:
                    radio_group = await self.page.locator(f'input[type="radio"][name="{name}"]').all()
                    for radio in radio_group:
                        try:
                            value = await radio.get_attribute('value')
                            label_text = await FieldDetector.get_label(radio)
                            if value or label_text:
                                options.append({
                                    'value': value or '',
                                    'label': label_text or ''
                                })
                        except Exception:
                            pass
        except Exception:
            pass
        return options
    
    async def _ask_user_for_value(self, field_info: Dict, locator) -> Optional[str]:
        """
        Ask user interactively for field value when not found in config
        """
        field_type = field_info.get('type', 'unknown')
        field_label = field_info.get('label') or field_info.get('name') or field_info.get('id') or 'Unknown'
        field_name = field_info.get('name') or ''
        field_id = field_info.get('id') or ''
        
        print('\n' + '='*70)
        print(f'[INTERACTIVE] Field not found in config!')
        print('='*70)
        print(f'Field Type: {field_type}')
        print(f'Field Label: {field_label}')
        if field_name:
            print(f'Field Name: {field_name}')
        if field_id:
            print(f'Field ID: {field_id}')
        if field_info.get('placeholder'):
            print(f'Placeholder: {field_info.get("placeholder")}')
        
        # Get options if select or radio
        options = []
        if field_type in ['select', 'radio']:
            options = await self._get_field_options(locator, field_type)
            if options:
                print(f'\nAvailable Options:')
                for i, opt in enumerate(options, 1):
                    value_str = opt.get('value', '')
                    label_str = opt.get('label', '')
                    if value_str and label_str:
                        print(f'  {i}. Value: "{value_str}" | Label: "{label_str}"')
                    elif value_str:
                        print(f'  {i}. Value: "{value_str}"')
                    elif label_str:
                        print(f'  {i}. Label: "{label_str}"')
        
        print('\n' + '-'*70)
        if field_type == 'checkbox':
            print('Enter value (true/1/yes to check, false/0/no to uncheck, or press Enter to skip):')
        elif options:
            print('Enter the value or label number (or press Enter to skip):')
        else:
            print('Enter value (or press Enter to skip):')
        print('-'*70)
        
        try:
            user_input = input('> ').strip()
            if not user_input:
                print('[SKIP] User chose to skip this field\n')
                return None
            
            # For select/radio with options, check if user entered a number
            if options and user_input.isdigit():
                user_num = user_input
                # First, check if this number matches any option's VALUE
                matching_option = None
                for opt in options:
                    opt_value = str(opt.get('value', '')).strip()
                    if opt_value == user_num:
                        matching_option = opt
                        print(f'[INFO] Found matching option by VALUE: value="{opt_value}", label="{opt.get("label", "")}"')
                        break
                
                if matching_option:
                    # Use the value directly
                    selected_value = matching_option.get('value') or matching_option.get('label', '')
                    print(f'[OK] Selected option by VALUE: "{selected_value}"\n')
                    return selected_value
                
                # If no value match, treat as index (1-based)
                # IMPORTANT: Skip placeholder options (usually first option with empty value)
                option_index = int(user_input) - 1
                if 0 <= option_index < len(options):
                    selected_option = options[option_index]
                    opt_value = str(selected_option.get('value', '')).strip()
                    opt_label = selected_option.get('label', '')
                    
                    # Check if this is a placeholder option (empty value and label matches field label)
                    # Skip placeholder options - they're usually disabled
                    if opt_value == '' and opt_label:
                        # This might be a placeholder, check if we should skip it
                        # If user selected index 1 and it's placeholder, try next option
                        if option_index == 0:
                            print(f'[WARNING] Selected option {option_index + 1} appears to be a placeholder (value="", label="{opt_label}")')
                            if len(options) > 1:
                                print(f'[INFO] Skipping placeholder, using next option...')
                                selected_option = options[1]
                                opt_value = str(selected_option.get('value', '')).strip()
                                opt_label = selected_option.get('label', '')
                            else:
                                print(f'[WARNING] No other options available, using placeholder anyway')
                    
                    # Use value if available, otherwise use label
                    user_input = opt_value if opt_value else opt_label
                    print(f'[OK] Selected option by INDEX ({option_index + 1}): value="{opt_value}", label="{opt_label}" -> using "{user_input}"\n')
                    return user_input
                else:
                    print(f'[WARNING] Index {option_index + 1} is out of range (1-{len(options)}), treating as value\n')
            
            print(f'[OK] Using value: "{user_input}"\n')
            return user_input
        except (EOFError, KeyboardInterrupt):
            print('\n[SKIP] Input cancelled, skipping field\n')
            return None
    
    def _get_config_value_for_field(self, field_info: Dict, personal_info: Dict, 
                                     file_paths: Dict, questions: Dict, talent_pool: Dict) -> Optional[Any]:
        """
        Get config value for a field based on field mappings
        """
        field_name = (field_info.get('name') or '').lower()
        field_id = (field_info.get('id') or '').lower()
        label = (field_info.get('label') or '').lower()
        placeholder = (field_info.get('placeholder') or '').lower()
        
        # Field mappings
        field_mappings = {
            'first_name': personal_info.get('first_name'),
            'firstname': personal_info.get('first_name'),
            'vorname': personal_info.get('first_name'),
            'first name': personal_info.get('first_name'),
            'given-name': personal_info.get('first_name'),
            'name': personal_info.get('first_name'),  # Generic name field often means first name
            'last_name': personal_info.get('last_name'),
            'lastname': personal_info.get('last_name'),
            'nachname': personal_info.get('last_name'),
            'last name': personal_info.get('last_name'),
            'family-name': personal_info.get('last_name'),
            'email': personal_info.get('email'),
            'e-mail': personal_info.get('email'),
            'mail': personal_info.get('email'),  # Short form of email
            'e-mail-adresse': personal_info.get('email'),
            'email-adresse': personal_info.get('email'),
            'phone': personal_info.get('phone'),
            'telephone': personal_info.get('phone'),
            'telefon': personal_info.get('phone'),
            'tel': personal_info.get('phone'),
            'date_of_birth': personal_info.get('date_of_birth') or personal_info.get('birth_date'),
            'birth_date': personal_info.get('date_of_birth') or personal_info.get('birth_date'),
            'geburtsdatum': personal_info.get('date_of_birth') or personal_info.get('birth_date'),
            'birth date': personal_info.get('date_of_birth') or personal_info.get('birth_date'),
            'date of birth': personal_info.get('date_of_birth') or personal_info.get('birth_date'),
            'birthdate': personal_info.get('date_of_birth') or personal_info.get('birth_date'),
            # Birth year
            'birth_year': personal_info.get('birth_year'),
            'year': personal_info.get('birth_year'),
            'geburtsjahr': personal_info.get('birth_year'),
            'gender': personal_info.get('gender'),
            'sex': personal_info.get('gender'),
            'geschlecht': personal_info.get('gender'),
            'country': personal_info.get('country'),
            'land': personal_info.get('country'),
            # Standort (location in German)
            'standort': personal_info.get('location') or questions.get('preferred_location'),
            # File uploads - Resume/CV
            'resume': file_paths.get('resume') or file_paths.get('cv'),
            'résume': file_paths.get('resume') or file_paths.get('cv'),  # With accent
            'cv': file_paths.get('resume') or file_paths.get('cv'),
            'lebenslauf': file_paths.get('resume') or file_paths.get('cv'),
            'lebenslauf / cv': file_paths.get('resume') or file_paths.get('cv'),
            'file-upload': file_paths.get('resume') or file_paths.get('cv'),
            'file_app_map': file_paths.get('resume') or file_paths.get('cv'),
            'wbnformextension[]': file_paths.get('resume') or file_paths.get('cv'),
            'wbn-form-extension': file_paths.get('resume') or file_paths.get('cv'),
            'form_field_resume': file_paths.get('resume') or file_paths.get('cv'),  # For id="form_field_resume"
            # File uploads - Cover letter
            'cover_letter': file_paths.get('cover_letter'),
            'cover letter': file_paths.get('cover_letter'),  # With space
            'motivationsschreiben': file_paths.get('cover_letter'),
            'anschreiben': file_paths.get('cover_letter'),
            'file_cover_letter': file_paths.get('cover_letter'),
            'coverletter': file_paths.get('cover_letter'),  # No space
            'form_field_coverletter': file_paths.get('cover_letter'),  # For id="form_field_coverLetter"
            'form_field_cover_letter': file_paths.get('cover_letter'),  # Alternative format
            # File uploads - Photo
            'photo': file_paths.get('photo'),
            'profile': file_paths.get('photo'),
            'profile_picture': file_paths.get('photo'),
            'profile picture': file_paths.get('photo'),
            'foto': file_paths.get('photo'),
            'bild': file_paths.get('photo'),
            'profilbild': file_paths.get('photo'),
            'profil bild': file_paths.get('photo'),
            'file_photo': file_paths.get('photo'),
            'job_experience': personal_info.get('job_experience') or questions.get('job_experience'),
            'professional experience': personal_info.get('job_experience') or questions.get('job_experience'),
            'berufserfahrung': personal_info.get('job_experience') or questions.get('job_experience'),
            'experience': personal_info.get('job_experience') or questions.get('job_experience'),
            'career_levels': talent_pool.get('career_levels') if talent_pool else None,
            'karrierestufe': talent_pool.get('career_levels') if talent_pool else None,
            # Location/City
            'location': personal_info.get('location') or questions.get('preferred_location'),
            'city': personal_info.get('location') or questions.get('preferred_location'),
            'stadt': personal_info.get('location') or questions.get('preferred_location'),
            'ort': personal_info.get('location') or questions.get('preferred_location'),
            'preferred_location': questions.get('preferred_location') or personal_info.get('location'),
            # Address
            'address': personal_info.get('address'),
            'adresse': personal_info.get('address'),
            'street': personal_info.get('street'),
            'straße': personal_info.get('street'),
            'postcode': personal_info.get('postcode'),
            'postal_code': personal_info.get('postcode'),
            'zip': personal_info.get('postcode'),
            'zipcode': personal_info.get('postcode'),
            'postleitzahl': personal_info.get('postcode'),
            'plz': personal_info.get('postcode'),
            # Language knowledge
            'german_knowledge': personal_info.get('german_knowledge'),
            'deutsch': personal_info.get('german_knowledge'),
            'german': personal_info.get('german_knowledge'),
            'german_level': questions.get('german_level') or personal_info.get('german_knowledge'),
            'deutschkenntnisse': questions.get('german_level') or personal_info.get('german_knowledge'),
            'welches sprachlevel in deutsch': questions.get('german_level') or personal_info.get('german_knowledge'),
            'sprachlevel in deutsch': questions.get('german_level') or personal_info.get('german_knowledge'),
            'question_answers': questions.get('german_level') or personal_info.get('german_knowledge'),
            # Remote work / Home office
            'remote': questions.get('remote_work'),
            'heimarbeit': questions.get('remote_work'),
            'remote/heimarbeit bevorzugt': questions.get('remote_work'),
            'remote bevorzugt': questions.get('remote_work'),
            'home office': questions.get('remote_work'),
            'english_knowledge': personal_info.get('english_knowledge'),
            'englisch': personal_info.get('english_knowledge'),
            'english': personal_info.get('english_knowledge'),
            # Education
            'graduation': personal_info.get('graduation'),
            'highest degree': personal_info.get('graduation'),
            'höchster abschluss': personal_info.get('graduation'),
            'höchster_abschluss': personal_info.get('graduation'),
            'degree': personal_info.get('graduation'),
            'abschluss': personal_info.get('graduation'),
            'graduated_as': personal_info.get('graduated_as'),
            'university degree as': personal_info.get('graduated_as'),
            'hochschulabschluss als': personal_info.get('graduated_as'),
            'degree as': personal_info.get('graduated_as'),
            'studienfach': personal_info.get('graduated_as'),
            'vocational_training': personal_info.get('vocational_training'),
            'berufsausbildung': personal_info.get('vocational_training'),
            'vocational training': personal_info.get('vocational_training'),
            # Comments/Cover letter
            'comment': personal_info.get('comment'),
            'kommentar': personal_info.get('comment'),
            'comments': personal_info.get('comment'),
            'cover_letter_text': personal_info.get('comment') or personal_info.get('cover_letter_text'),
            'anschreiben': personal_info.get('comment'),
            # Salary
            'salary': questions.get('salary'),
            'gehalt': questions.get('salary'),
            # Remote work
            'remote_work': questions.get('remote_work'),
            'home_office': questions.get('remote_work'),
            # Start date
            'earliest_start': questions.get('earliest_start'),
            'earliest_start_date': questions.get('earliest_start_date'),
            'start_date': questions.get('earliest_start_date'),
            'earliest possible starting date': questions.get('earliest_start_date') or '2025-12-15',
            'earliest possible start date': questions.get('earliest_start_date') or '2025-12-15',
            'earliest possible start': questions.get('earliest_start_date') or '2025-12-15',
            'possible starting date': questions.get('earliest_start_date') or '2025-12-15',
            'starting date': questions.get('earliest_start_date') or '2025-12-15',
        }
        
        # Talent pool fields (check first)
        if talent_pool:
            talent_pool_mappings = {
                'job_title': talent_pool.get('job_title'),
                'wunschberuf': talent_pool.get('job_title'),
                'location': talent_pool.get('location'),
                'search_geo': talent_pool.get('location'),
                'wunschort': talent_pool.get('location'),
                'radius': talent_pool.get('radius'),
                'geo_radius': talent_pool.get('radius'),
                'salary': talent_pool.get('salary'),
                'gehaltswunsch': talent_pool.get('salary'),
                'salary_currency': talent_pool.get('salary_currency'),
                'salary_type': talent_pool.get('salary_type'),
                'job_time_model': talent_pool.get('job_time_model'),
                'arbeitszeit': talent_pool.get('job_time_model'),
                'job_categories': talent_pool.get('job_categories'),
                'kategorie': talent_pool.get('job_categories'),
                'career_levels': talent_pool.get('career_levels'),
                'karrierestufe': talent_pool.get('career_levels'),
            }
            
            # Check talent pool mappings by name
            if field_name in talent_pool_mappings:
                value = talent_pool_mappings[field_name]
                if value:
                    return value
            
            # Check talent pool mappings by id
            if field_id in talent_pool_mappings:
                value = talent_pool_mappings[field_id]
                if value:
                    return value
            
            # Check talent pool mappings by label
            if label:
                for key, value in talent_pool_mappings.items():
                    if key in label and value:
                        return value
        
        # Check by name
        if field_name in field_mappings:
            value = field_mappings[field_name]
            if value:
                return value
        
        # Check by id
        if field_id in field_mappings:
            value = field_mappings[field_id]
            if value:
                return value
        
        # Check by label (exact match first, then partial match)
        if label:
            lower_label = label.lower().strip()
            # Remove asterisks, punctuation, and other special characters for matching
            clean_label = re.sub(r'[^\w\s]', '', lower_label).strip()  # Remove all punctuation
            clean_label = clean_label.replace('*', '').replace('**', '').strip()
            # Also remove extra spaces
            clean_label = ' '.join(clean_label.split())
            
            # Exact match with clean label
            if clean_label in field_mappings:
                value = field_mappings[clean_label]
                if value:
                    return value
            
            # Exact match with original label
            if lower_label in field_mappings:
                value = field_mappings[lower_label]
                if value:
                    return value
            
            # Partial match with word boundaries (to avoid false positives)
            # IMPORTANT: For file uploads, allow label matching (e.g., "Résume" should match "résume")
            for key, value in field_mappings.items():
                if not value:
                    continue
                
                lower_key = key.lower()
                # Clean the key too (remove punctuation)
                clean_key = re.sub(r'[^\w\s]', '', lower_key).strip()
                clean_key = ' '.join(clean_key.split())
                
                # Exact match with clean label
                if clean_label == clean_key:
                    return value
                # Exact match with original label
                if lower_label == lower_key:
                    return value
                # Match at word boundaries
                if (lower_label.startswith(lower_key + ' ') or
                    lower_label.endswith(' ' + lower_key) or
                    lower_label.find(' ' + lower_key + ' ') != -1):
                    return value
                # Match with clean label
                if (clean_label.startswith(clean_key + ' ') or
                    clean_label.endswith(' ' + clean_key) or
                    clean_label.find(' ' + clean_key + ' ') != -1):
                    return value
                # Check if clean_label contains clean_key (for cases like "Please enter your earliest possible starting date" contains "earliest possible starting date")
                if clean_key in clean_label:
                    return value
                # For file uploads, also check if label contains the key (e.g., "Résume*" contains "résume")
                is_file_upload = isinstance(value, str) and ('./doc/' in value or '.pdf' in value or '.jpg' in value or '.jpeg' in value)
                if is_file_upload and lower_key in lower_label:
                    return value
        
        # Check by placeholder (only if label didn't match)
        # Placeholder is less reliable, so we check it after label
        if placeholder and placeholder.strip() and placeholder != 'bitte eingeben':
            # Skip generic placeholders
            generic_placeholders = ['bitte eingeben', 'please enter', 'enter', 'eingeben', 'placeholder']
            if placeholder.strip() not in generic_placeholders:
                placeholder_clean = placeholder.strip()
                
                # Exact match with placeholder
                if placeholder_clean in field_mappings:
                    value = field_mappings[placeholder_clean]
                    if value:
                        return value
                
                # Partial match with placeholder
                for key, value in field_mappings.items():
                    if not value:
                        continue
                    # Skip file upload mappings when checking placeholders
                    if isinstance(value, str) and ('./doc/' in value or '.pdf' in value or '.jpg' in value or '.jpeg' in value):
                        continue
                    
                    lower_key = key.lower()
                    # Exact match
                    if placeholder_clean == lower_key:
                        return value
                    # Partial match
                    if (placeholder_clean.startswith(lower_key + ' ') or
                        placeholder_clean.endswith(' ' + lower_key) or
                        placeholder_clean.find(' ' + lower_key + ' ') != -1):
                        return value
        
        return None
    
    async def _fill_field_by_info(self, locator, field_info: Dict, value: Any) -> bool:
        """
        Fill a field based on its type
        """
        field_type = field_info.get('type', 'unknown')
        field_name = field_info.get('label') or field_info.get('name') or field_info.get('id') or 'Unknown'
        
        # Build selectors
        selectors = []
        if field_type == 'select':
            # For select fields, use select-specific selectors
            if field_info.get('id'):
                selectors.append(f'select#{field_info["id"]}')
                selectors.append(f'#{field_info["id"]}')  # Fallback
            if field_info.get('name'):
                selectors.append(f'select[name="{field_info["name"]}"]')
                selectors.append(f'[name="{field_info["name"]}"]')  # Fallback
        elif field_type == 'file':
            # For file inputs, use file-specific selectors
            if field_info.get('id'):
                selectors.append(f'input[type="file"]#{field_info["id"]}')
                selectors.append(f'#{field_info["id"]}')  # Fallback
            if field_info.get('name'):
                selectors.append(f'input[type="file"][name="{field_info["name"]}"]')
                selectors.append(f'[name="{field_info["name"]}"]')  # Fallback
        else:
            # For other fields, use generic selectors
            if field_info.get('id'):
                selectors.append(f'#{field_info["id"]}')
            if field_info.get('name'):
                selectors.append(f'[name="{field_info["name"]}"]')
        
        if not selectors:
            return False
        
        try:
            if field_type == 'text' or field_type == 'email' or field_type == 'tel' or field_type == 'textarea':
                return await TextFieldFiller.fill(self.page, selectors, str(value), field_name)
            elif field_type == 'select':
                return await SelectFieldFiller.fill(self.page, selectors, str(value), field_name)
            elif field_type == 'date':
                return await DatePickerFiller.fill(self.page, selectors, str(value), field_name)
            elif field_type == 'file':
                return await FileUploadFiller.fill(self.page, selectors, str(value), field_name)
            elif field_type == 'radio':
                name_selector = f'[name="{field_info["name"]}"]' if field_info.get('name') else selectors[0]
                field_label = field_info.get('label') or field_name
                # Pass the original locator to help identify the correct radio group
                return await RadioFieldFiller.fill(self.page, name_selector, str(value), field_name, field_label, locator)
            elif field_type == 'checkbox':
                return await CheckboxFieldFiller.fill(self.page, selectors, bool(value), field_name)
            else:
                # Try text filler as fallback
                return await TextFieldFiller.fill(self.page, selectors, str(value), field_name)
        except Exception as e:
            print(f'[WARNING] Error filling field {field_name}: {str(e)}')
            return False
    
    async def fill_all_fields(self) -> None:
        """
        Fill all form fields based on configuration
        """
        if not self.page:
            print('[ERROR] No page object available')
            return
        
        personal_info = self.config.get('personal_info', {})
        file_paths = self.config.get('file_paths', {})
        questions = self.config.get('questions', {})
        talent_pool = self.config.get('talent_pool', {})
        
        # Get all form fields sorted by position
        fields = await self._get_form_fields_in_order()
        print(f'\nFound {len(fields)} form fields. Processing in order...\n')
        
        processed_field_names: Set[str] = set()
        
        # Process fields
        for idx, field in enumerate(fields, 1):
            field_info = await self._get_field_info(field)
            field_label = field_info.get('label') or field_info.get('name') or field_info.get('id') or 'Unknown'
            field_type = field_info.get('type') or 'unknown'
            field_name = field_info.get('name') or ''
            field_id = field_info.get('id') or ''
            
            # Check if field was already processed (but allow file inputs to be processed even if "processed" - they might need retry)
            field_key = f"{field_name}_{field_id}_{field_type}"
            if field_type != 'file':
                if field_name and field_name in processed_field_names:
                    print(f'[SKIP] Field: "{field_label}" ({field_type}) - Already processed, skipping')
                    continue
                if field_id and field_id in processed_field_names:
                    print(f'[SKIP] Field: "{field_label}" ({field_type}) - Already processed, skipping')
                    continue
            
            # Check if field is already filled (but for file inputs, be less strict - they might appear filled but not actually be)
            is_already_filled = await self._is_field_filled(field, field_info)
            if is_already_filled and field_type != 'file':
                print(f'[SKIP] Field: "{field_label}" ({field_type}) - Already filled, skipping')
                # Mark as processed
                if field_name:
                    processed_field_names.add(field_name)
                if field_id:
                    processed_field_names.add(field_id)
                continue
            
            config_value = self._get_config_value_for_field(field_info, personal_info, file_paths, questions, talent_pool)
            
            # Handle talent pool checkbox
            if field_info.get('type') == 'checkbox' and (field_info.get('name') == 'app_register' or field_info.get('id') == 'app_register_btn'):
                if questions.get('talent_pool_enabled') is True:
                    print(f'[OK] Field: "{field_info.get("label") or field_info.get("name")}" (checkbox) - Checking talent pool checkbox')
                    try:
                        checkbox = self.page.locator(f'input[name="{field_info.get("name")}"], input#{field_info.get("id")}').first
                        if await checkbox.count() > 0:
                            is_checked = await checkbox.is_checked()
                            if not is_checked:
                                await checkbox.check()
                                print('[OK] Talent pool checkbox checked')
                                await self.page.wait_for_timeout(2000)
                                await self._fill_talent_pool_fields(talent_pool, processed_field_names)
                    except Exception as e:
                        print(f'[WARNING] Error checking talent pool checkbox: {str(e)}')
            
            if config_value is not None and config_value != '':
                print(f'[OK] Field: "{field_label}" ({field_type}) - Value in config: "{config_value}"')
                await self._fill_field_by_info(field, field_info, config_value)
                
                if field_info.get('name'):
                    processed_field_names.add(field_info['name'])
                if field_info.get('id'):
                    processed_field_names.add(field_info['id'])
                
                # Check for newly visible fields after file upload
                if field_info.get('name') in ['file_app_map', 'file_cover_letter']:
                    print(f'\n[INFO] Checking for newly visible fields after {field_info.get("name")} upload...')
                    await self.page.wait_for_timeout(2000)
                    
                    if file_paths.get('photo') and 'file_photo' not in processed_field_names:
                        try:
                            photo_input = self.page.locator('input[name="file_photo"]').first
                            if await photo_input.count() > 0:
                                is_visible = await photo_input.is_visible()
                                if is_visible:
                                    photo_field_info = await self._get_field_info(photo_input)
                                    photo_config_value = self._get_config_value_for_field(photo_field_info, personal_info, file_paths, questions, talent_pool)
                                    if photo_config_value:
                                        print(f'[OK] Found newly visible photo field: "{photo_field_info.get("label") or photo_field_info.get("name")}" - Value in config: "{photo_config_value}"')
                                        await self._fill_field_by_info(photo_input, photo_field_info, photo_config_value)
                                        processed_field_names.add('file_photo')
                        except Exception:
                            pass
            else:
                # Ask user interactively for value
                user_value = await self._ask_user_for_value(field_info, field)
                if user_value is not None and user_value != '':
                    print(f'[OK] Field: "{field_label}" ({field_type}) - Using user-provided value: "{user_value}"')
                    success = await self._fill_field_by_info(field, field_info, user_value)
                    if success:
                        # Wait a bit for field to update
                        await self.page.wait_for_timeout(300)
                        # Verify field was filled
                        is_filled = await self._is_field_filled(field, field_info)
                        if is_filled:
                            # Mark as processed
                            if field_info.get('name'):
                                processed_field_names.add(field_info['name'])
                            if field_info.get('id'):
                                processed_field_names.add(field_info['id'])
                            print(f'[OK] Field "{field_label}" successfully filled and marked as processed')
                        else:
                            print(f'[WARNING] Field "{field_label}" may not have been filled correctly')
                    else:
                        print(f'[WARNING] Failed to fill field "{field_label}"')
                else:
                    print(f'[SKIP] Field: "{field_label}" ({field_type}) - No value provided, skipping')
                    # Mark as processed even if skipped to avoid asking again
                    if field_info.get('name'):
                        processed_field_names.add(field_info['name'])
                    if field_info.get('id'):
                        processed_field_names.add(field_info['id'])
        
        # Check all visible checkboxes
        await self._check_all_checkboxes(processed_field_names)
        
        print('\n[OK] All fields processed')
    
    async def _check_all_checkboxes(self, processed_field_names: Set[str]) -> None:
        """
        Check all visible checkboxes in the form
        Prioritizes checkboxes with * in label (required fields)
        """
        print('\n[INFO] Checking all visible checkboxes...')
        
        if not self.page:
            return
        
        try:
            all_checkboxes = await self.page.evaluate("""
                () => {
                    const nativeCheckboxes = Array.from(document.querySelectorAll('input[type="checkbox"]'));
                    const customCheckboxes = Array.from(document.querySelectorAll('[role="checkbox"], [role="switch"]'));
                    const allCb = [...nativeCheckboxes, ...customCheckboxes];
                    const uniqueCb = Array.from(new Set(allCb));
                    
                    return uniqueCb
                        .filter(cb => {
                            const style = window.getComputedStyle(cb);
                            return (
                                style.display !== 'none' &&
                                style.visibility !== 'hidden' &&
                                style.opacity !== '0' &&
                                cb.offsetWidth > 0 &&
                                cb.offsetHeight > 0 &&
                                !cb.disabled &&
                                !cb.readOnly
                            );
                        })
                        .map(cb => {
                            const isChecked = cb.type === 'checkbox' 
                                ? cb.checked 
                                : (cb.getAttribute('aria-checked') === 'true');
                            
                            // Get label text
                            let labelText = '';
                            if (cb.id) {
                                const label = document.querySelector(`label[for="${cb.id}"]`);
                                if (label) labelText = label.textContent?.trim() || '';
                            }
                            if (!labelText) {
                                const parentLabel = cb.closest('label');
                                if (parentLabel) labelText = parentLabel.textContent?.trim() || '';
                            }
                            if (!labelText) {
                                const ariaLabel = cb.getAttribute('aria-label');
                                if (ariaLabel) labelText = ariaLabel;
                            }
                            
                            // Check for * in label or nearby text
                            let hasAsterisk = labelText.includes('*');
                            if (!hasAsterisk) {
                                let parent = cb.parentElement;
                                let depth = 0;
                                while (parent && depth < 5) {
                                    const parentText = parent.textContent || '';
                                    if (parentText.includes('*')) {
                                        hasAsterisk = true;
                                        break;
                                    }
                                    parent = parent.parentElement;
                                    depth++;
                                }
                            }
                            
                            return {
                                name: cb.name || '',
                                id: cb.id || '',
                                checked: isChecked,
                                ariaLabel: cb.getAttribute('aria-label') || '',
                                role: cb.getAttribute('role') || '',
                                isCustom: cb.type !== 'checkbox',
                                label: labelText,
                                hasAsterisk: hasAsterisk
                            };
                        });
                }
            """)
            
            # Sort: required fields (with *) first
            all_checkboxes.sort(key=lambda x: (not x['hasAsterisk'], x['name']))
            
            checked_count = 0
            for checkbox in all_checkboxes:
                label_text = checkbox.get('label', '')
                is_required = checkbox.get('hasAsterisk', False)
                
                # Skip if already processed (unless required)
                if not is_required:
                    if checkbox.get('name') and checkbox['name'] in processed_field_names:
                        continue
                    if checkbox.get('id') and checkbox['id'] in processed_field_names:
                        continue
                
                # Skip if already checked (unless required)
                if checkbox.get('checked') and not is_required:
                    continue
                
                if is_required:
                    print(f'[INFO] Required checkbox (contains *): "{label_text}" - will check it')
                else:
                    print(f'[INFO] Attempting to check: "{label_text}"')
                
                # Build selector
                selectors = []
                if checkbox.get('id'):
                    selectors.append(f'#{checkbox["id"]}')
                if checkbox.get('name'):
                    selectors.append(f'input[name="{checkbox["name"]}"]')
                
                if not selectors:
                    continue
                
                locator = self.page.locator(selectors[0]).first
                if await locator.count() > 0:
                    is_visible = await locator.is_visible()
                    if is_visible:
                        is_checked = False
                        if checkbox.get('isCustom'):
                            aria_checked = await locator.get_attribute('aria-checked')
                            is_checked = aria_checked == 'true'
                        else:
                            is_checked = await locator.is_checked()
                        
                        if not is_checked or is_required:
                            await locator.scroll_into_view_if_needed()
                            await self.page.wait_for_timeout(200)
                            
                            check_success = False
                            
                            if checkbox.get('isCustom'):
                                try:
                                    await locator.click()
                                    await locator.evaluate("""
                                        (el) => {
                                            el.setAttribute('aria-checked', 'true');
                                            const event = new Event('change', { bubbles: true });
                                            el.dispatchEvent(event);
                                        }
                                    """)
                                    check_success = True
                                except Exception:
                                    pass
                            else:
                                try:
                                    await locator.check(force=True)
                                    verified = await locator.is_checked()
                                    if verified:
                                        check_success = True
                                    else:
                                        raise Exception('check() did not change state')
                                except Exception:
                                    try:
                                        await locator.click(force=True)
                                        await self.page.wait_for_timeout(100)
                                        verified = await locator.is_checked()
                                        if verified:
                                            check_success = True
                                        else:
                                            raise Exception('click() did not change state')
                                    except Exception:
                                        try:
                                            await locator.evaluate("""
                                                (el) => {
                                                    el.checked = true;
                                                    const changeEvent = new Event('change', { bubbles: true, cancelable: true });
                                                    el.dispatchEvent(changeEvent);
                                                    const clickEvent = new Event('click', { bubbles: true, cancelable: true });
                                                    el.dispatchEvent(clickEvent);
                                                    const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                                                    el.dispatchEvent(inputEvent);
                                                }
                                            """)
                                            await self.page.wait_for_timeout(100)
                                            verified = await locator.is_checked()
                                            if verified:
                                                check_success = True
                                        except Exception:
                                            pass
                            
                            if check_success or is_required:
                                final_checked = False
                                if checkbox.get('isCustom'):
                                    aria_checked = await locator.get_attribute('aria-checked')
                                    final_checked = aria_checked == 'true'
                                else:
                                    final_checked = await locator.is_checked()
                                
                                if final_checked or is_required:
                                    print(f'[OK] Checked: "{label_text}"')
                                    checked_count += 1
                                    if checkbox.get('name'):
                                        processed_field_names.add(checkbox['name'])
                                    if checkbox.get('id'):
                                        processed_field_names.add(checkbox['id'])
                                    await self.page.wait_for_timeout(500)
            
            print(f'[OK] Checked {checked_count} checkbox(es)')
        except Exception as e:
            print(f'[WARNING] Error checking checkboxes: {str(e)}')
    
    async def _fill_talent_pool_fields(self, talent_pool: Dict, processed_field_names: Set[str]) -> None:
        """
        Fill talent pool fields (career_levels, etc.)
        """
        if not talent_pool or not self.page:
            return
        
        print('\n[INFO] Filling talent pool fields...')
        
        # Handle career_levels (selectize multiple select)
        career_levels = talent_pool.get('career_levels')
        if career_levels and isinstance(career_levels, list) and len(career_levels) > 0:
            try:
                # Try to find selectize input
                selectize_input = self.page.locator('input.selectize-input, .selectize-input input, [class*="selectize"] input').first
                if await selectize_input.count() > 0:
                    is_visible = await selectize_input.is_visible()
                    if is_visible:
                        await selectize_input.scroll_into_view_if_needed()
                        await selectize_input.click()
                        await self.page.wait_for_timeout(500)
                        
                        # Try using selectize API
                        try:
                            selectize_id = await selectize_input.get_attribute('id')
                            if selectize_id:
                                await self.page.evaluate(f"""
                                    (values) => {{
                                        const selectize = $('#{selectize_id}').selectize();
                                        if (selectize && selectize.length > 0) {{
                                            const instance = selectize[0].selectize;
                                            if (instance) {{
                                                values.forEach(val => {{
                                                    instance.setValue(val, true);
                                                }});
                                                instance.trigger('change');
                                            }}
                                        }}
                                    }}
                                """, career_levels)
                                print(f'[OK] Career levels set via selectize API: {career_levels}')
                                await self.page.wait_for_timeout(1000)
                        except Exception:
                            # Fallback: try clicking options in dropdown
                            for value in career_levels:
                                try:
                                    option = self.page.locator(f'.selectize-dropdown [data-value="{value}"], .selectize-dropdown:has-text("{value}")').first
                                    if await option.count() > 0:
                                        await option.click()
                                        await self.page.wait_for_timeout(300)
                                except Exception:
                                    pass
                        
                        # Final fallback: direct selection on hidden select
                        try:
                            hidden_select = self.page.locator('select.selectize').first
                            if await hidden_select.count() > 0:
                                for value in career_levels:
                                    try:
                                        await hidden_select.select_option(value=value)
                                    except Exception:
                                        pass
                        except Exception:
                            pass
            except Exception:
                pass
        
        # Handle other talent pool fields
        for key, value in talent_pool.items():
            if key == 'career_levels':
                continue  # Already handled
            
            if value and value != '':
                try:
                    field = self.page.locator(f'[name="{key}"], #{key}').first
                    if await field.count() > 0:
                        field_info = await self._get_field_info(field)
                        await self._fill_field_by_info(field, field_info, value)
                except Exception:
                    pass
    
    async def _submit_form(self) -> None:
        """
        Submit the form by clicking the bottom-most submit button
        """
        if not self.page:
            return
        
        print('\n[INFO] ========================================')
        print('[INFO] Starting form submission...')
        print('[INFO] ========================================')
        
        try:
            # Find all submit-like buttons and links
            # Include both <button> and <a> tags that act as submit buttons
            submit_selectors = [
                # Standard button selectors
                'button[type="submit"]',
                'input[type="submit"]',
                'button:has-text("Submit")',
                'button:has-text("Absenden")',
                'button:has-text("Senden")',
                'button:has-text("Bewerbung absenden")',
                'button:has-text("Bewerbung abschicken")',
                'button[name="invalidButton"]',
                'button.btn-primary[type="submit"]',
                'button[role="button"][type="submit"]',
                '[type="submit"]',
                'form button[type="submit"]',
                # Link-based submit buttons (<a> tags)
                'a#submitButton',
                'a[id*="submit"]',
                'a[class*="submit"]',
                'a.btn-primary:has-text("Absenden")',
                'a.btn-primary:has-text("Submit")',
                'a.btn-primary:has-text("Senden")',
                'a.btn:has-text("Absenden")',
                'a.btn:has-text("Submit")',
                'a.btn:has-text("Senden")',
                'a:has-text("Absenden")',
                'a:has-text("Submit")',
                'a:has-text("Senden")',
                'a:has-text("Bewerbung absenden")',
                'a:has-text("Bewerbung abschicken")',
                'a.btn-primary',
                'a.btn[class*="primary"]',
                # Generic patterns
                'a[href*="submit"]',
                'a[onclick*="submit"]'
            ]
            
            all_buttons = []
            for selector in submit_selectors:
                try:
                    elements = await self.page.locator(selector).all()
                    print(f'[DEBUG] Submit selector "{selector}": found {len(elements)} element(s)')
                    for element in elements:
                        try:
                            is_visible = await element.is_visible()
                            if is_visible:
                                # Get element tag name to distinguish between button and link
                                tag_name = await element.evaluate('el => el.tagName.toLowerCase()')
                                is_link = tag_name == 'a'
                                
                                # Get element text to filter out "Hinzufügen" (Add) buttons
                                element_text = await element.text_content()
                                element_text = element_text.strip() if element_text else ''
                                element_name = await element.get_attribute('name')
                                element_type = await element.get_attribute('type')
                                element_id = await element.get_attribute('id')
                                element_class = await element.get_attribute('class') or ''
                                
                                print(f'[DEBUG] Found element ({tag_name}): text="{element_text}", name="{element_name}", type="{element_type}", id="{element_id}"')
                                
                                if element_text and 'hinzufügen' not in element_text.lower() and 'add' not in element_text.lower():
                                    # For links, check if they look like submit buttons
                                    if is_link:
                                        # Check if link has submit-related text or classes
                                        has_submit_text = any(word in element_text.lower() for word in ['absenden', 'submit', 'senden', 'abschicken'])
                                        has_submit_class = 'btn-primary' in element_class or 'submit' in element_class.lower()
                                        
                                        if has_submit_text or has_submit_class or element_id == 'submitButton':
                                            print(f'[DEBUG] Link looks like submit button: has_submit_text={has_submit_text}, has_submit_class={has_submit_class}')
                                            rect = await element.bounding_box()
                                            if rect:
                                                all_buttons.append({
                                                    'button': element,
                                                    'y': rect['y'] + rect['height'],
                                                    'text': element_text,
                                                    'is_disabled': False,  # Links don't have disabled state
                                                    'has_opacity': False,
                                                    'is_link': True,
                                                    'tag_name': tag_name
                                                })
                                    else:
                                        # For buttons, check if disabled
                                        is_disabled = await element.is_disabled()
                                        disabled_attr = await element.get_attribute('disabled')
                                        
                                        # opacity-50 might indicate disabled, but we should still try
                                        has_opacity = 'opacity-50' in element_class
                                        
                                        print(f'[DEBUG] Button disabled check: is_disabled={is_disabled}, disabled_attr={disabled_attr}, has_opacity={has_opacity}')
                                        
                                        # Get position
                                        rect = await element.bounding_box()
                                        if rect:
                                            all_buttons.append({
                                                'button': element,
                                                'y': rect['y'] + rect['height'],
                                                'text': element_text,
                                                'is_disabled': is_disabled,
                                                'has_opacity': has_opacity,
                                                'is_link': False,
                                                'tag_name': tag_name
                                            })
                        except Exception as e:
                            print(f'[DEBUG] Error checking element: {str(e)}')
                            continue
                except Exception as e:
                    print(f'[DEBUG] Error with selector "{selector}": {str(e)}')
                    continue
            
            # If no buttons found, try searching by text content (for both buttons and links)
            if not all_buttons:
                print('[DEBUG] No elements found with selectors, trying text search...')
                try:
                    # Search both buttons and links
                    all_elements = await self.page.locator('button, a.btn, a[class*="btn"], a#submitButton').all()
                    for elem in all_elements:
                        try:
                            elem_text = await elem.text_content()
                            if elem_text:
                                elem_text_lower = elem_text.lower().strip()
                                # Check for submit-related text
                                if any(word in elem_text_lower for word in ['bewerbung', 'absenden', 'abschicken', 'submit', 'senden']):
                                    tag_name = await elem.evaluate('el => el.tagName.toLowerCase()')
                                    elem_type = await elem.get_attribute('type')
                                    elem_id = await elem.get_attribute('id')
                                    elem_class = await elem.get_attribute('class') or ''
                                    
                                    # For buttons, check type
                                    if tag_name == 'button':
                                        if elem_type == 'submit' or not elem_type:
                                            is_visible = await elem.is_visible()
                                            if is_visible:
                                                rect = await elem.bounding_box()
                                                if rect:
                                                    print(f'[DEBUG] Found button by text search: "{elem_text}", type="{elem_type}"')
                                                    all_buttons.append({
                                                        'button': elem,
                                                        'y': rect['y'] + rect['height'],
                                                        'text': elem_text.strip(),
                                                        'is_disabled': False,
                                                        'has_opacity': False,
                                                        'is_link': False,
                                                        'tag_name': tag_name
                                                    })
                                    # For links, check if it looks like a submit button
                                    elif tag_name == 'a':
                                        has_submit_class = 'btn-primary' in elem_class or 'btn' in elem_class or 'submit' in elem_class.lower()
                                        if has_submit_class or elem_id == 'submitButton':
                                            is_visible = await elem.is_visible()
                                            if is_visible:
                                                rect = await elem.bounding_box()
                                                if rect:
                                                    print(f'[DEBUG] Found link by text search: "{elem_text}", id="{elem_id}", class="{elem_class}"')
                                                    all_buttons.append({
                                                        'button': elem,
                                                        'y': rect['y'] + rect['height'],
                                                        'text': elem_text.strip(),
                                                        'is_disabled': False,
                                                        'has_opacity': False,
                                                        'is_link': True,
                                                        'tag_name': tag_name
                                                    })
                        except Exception as e:
                            print(f'[DEBUG] Error checking element in text search: {str(e)}')
                            continue
                except Exception as e:
                    print(f'[DEBUG] Error in text search: {str(e)}')
            
            # Note: Link selectors are now included in submit_selectors above
            # This section is kept for backward compatibility but is redundant now
            
            if all_buttons:
                # Sort by vertical position (bottom-most first)
                all_buttons.sort(key=lambda x: x['y'], reverse=True)
                
                # Try to find a non-disabled button first, otherwise use the first one
                submit_button_info = None
                for btn_info in all_buttons:
                    # For <a> tags, skip disabled check (they don't have disabled attribute)
                    is_link = btn_info.get('is_link', False)
                    if is_link or not btn_info.get('is_disabled', False):
                        submit_button_info = btn_info
                        break
                
                # If all are disabled or we didn't find one, use the first (bottom-most)
                if not submit_button_info:
                    submit_button_info = all_buttons[0]
                    print(f'[WARNING] All buttons appear disabled, trying anyway...')
                
                submit_element = submit_button_info['button']
                element_text = submit_button_info.get('text', '')
                is_link = submit_button_info.get('is_link', False)
                tag_name = submit_button_info.get('tag_name', 'button')
                
                print(f'[INFO] Submitting form with element ({tag_name}): "{element_text}"')
                await submit_element.scroll_into_view_if_needed()
                await self.page.wait_for_timeout(500)
                
                # Try multiple click methods (simple approach)
                try:
                    # Method 1: Regular click (works for both buttons and links)
                    print('[INFO] Attempting regular click...')
                    await submit_element.click(timeout=5000)
                    print(f'[OK] Form submitted (regular click on {tag_name})')
                except Exception as e1:
                    print(f'[WARNING] Regular click failed: {str(e1)}')
                    try:
                        # Method 2: Force click
                        print('[INFO] Attempting force click...')
                        await submit_element.click(force=True, timeout=5000)
                        print(f'[OK] Form submitted (force click on {tag_name})')
                    except Exception as e2:
                        print(f'[WARNING] Force click failed: {str(e2)}')
                        try:
                            # Method 3: JavaScript click
                            print('[INFO] Attempting JavaScript click...')
                            await submit_element.evaluate('el => el.click()')
                            print(f'[OK] Form submitted (JavaScript click on {tag_name})')
                        except Exception as e3:
                            print(f'[WARNING] JavaScript click failed: {str(e3)}')
                            try:
                                # Method 4: For links, try to submit form instead of navigating
                                if is_link:
                                    print('[INFO] Link detected - attempting to submit form directly instead of navigating...')
                                    # Don't navigate via href, instead try to submit the form
                                    await self.page.evaluate("""
                                        () => {
                                            const forms = document.querySelectorAll('form');
                                            for (const form of forms) {
                                                if (form.querySelector('input, select, textarea')) {
                                                    form.submit();
                                                    return true;
                                                }
                                            }
                                            return false;
                                        }
                                    """)
                                    print('[OK] Form submitted (direct form.submit() for link)')
                                else:
                                    # Method 5: Direct form submit for buttons
                                    print('[INFO] Attempting direct form.submit()...')
                                    success = await self.page.evaluate("""
                                        () => {
                                            const forms = document.querySelectorAll('form');
                                            for (const form of forms) {
                                                if (form.querySelector('input, select, textarea')) {
                                                    form.submit();
                                                    return true;
                                                }
                                            }
                                            return false;
                                        }
                                    """)
                                    if success:
                                        print('[OK] Form submitted (direct form.submit())')
                                    else:
                                        raise Exception('No form found to submit')
                            except Exception as e4:
                                print(f'[ERROR] All submit methods failed: {str(e4)}')
                                import traceback
                                print(traceback.format_exc())
                
                await self.page.wait_for_timeout(3000)
                
                # After submit, check for errors immediately
                print('\n[INFO] Checking for errors after submission...')
                await self.page.wait_for_timeout(1000)  # Wait for page to update
                
                # Check for error indicators
                error_check = await self.page.evaluate("""
                    () => {
                        const errors = [];
                        
                        // Check for is-invalid classes
                        const invalidFields = document.querySelectorAll('.is-invalid, [class*="is-invalid"]');
                        errors.push(`Found ${invalidFields.length} field(s) with is-invalid class`);
                        
                        // Check for error messages
                        const errorMessages = document.querySelectorAll('.text-danger, .invalid-feedback, .error, [class*="error"]');
                        const visibleErrors = Array.from(errorMessages).filter(el => {
                            const style = window.getComputedStyle(el);
                            return style.display !== 'none' && style.visibility !== 'hidden' && el.textContent.trim().length > 0;
                        });
                        errors.push(`Found ${visibleErrors.length} visible error message(s)`);
                        
                        // List first few error messages
                        visibleErrors.slice(0, 5).forEach((el, idx) => {
                            errors.push(`Error ${idx + 1}: "${el.textContent.trim()}"`);
                        });
                        
                        return errors;
                    }
                """)
                
                print('[INFO] Error check results:')
                for error_info in error_check:
                    print(f'   {error_info}')
                
            else:
                print('[WARNING] No submit button found')
        except Exception as e:
            print(f'[WARNING] Error submitting form: {str(e)}')
            import traceback
            print(traceback.format_exc())
    
    async def _smart_error_recovery(self) -> bool:
        """
        Smart error recovery: Re-scan form, identify errors, and fix them intelligently
        Returns True if errors were fixed
        """
        try:
            print('\n[INFO] ========================================')
            print('[INFO] Starting smart error recovery...')
            print('[INFO] ========================================')
            
            personal_info = self.config.get('personal_info', {})
            file_paths = self.config.get('file_paths', {})
            questions = self.config.get('questions', {})
            talent_pool = self.config.get('talent_pool', {})
            
            # Step 1: Find all error messages and fields with is-invalid class
            print('[INFO] Step 1: Scanning page for errors...')
            error_data = await self.page.evaluate("""
                () => {
                    const errors = [];
                    const errorSelectors = [
                        '.invalid-feedback',
                        '.error',
                        '.alert-danger',
                        '.validation-error',
                        '.field-error',
                        '[class*="error"]',
                        '[role="alert"]',
                        '.text-danger',
                        '.js-validation-message',
                        '.text-sm.block.text-danger',
                        '.mb-1.text-sm.block.text-danger'
                    ];
                    
                    // Also find fields with is-invalid class (PRIORITY METHOD)
                    const invalidFields = document.querySelectorAll('.is-invalid, [class*="is-invalid"]');
                    console.log(`Found ${invalidFields.length} container(s) with is-invalid class`);
                    
                    invalidFields.forEach((fieldContainer, idx) => {
                        console.log(`Processing invalid container ${idx + 1}...`);
                        
                        // Find error message in this container FIRST
                        const errorMsg = fieldContainer.querySelector('.text-danger, .invalid-feedback, .error, [class*="error"], .mb-1.text-sm.block.text-danger');
                        const errorText = errorMsg ? errorMsg.textContent.trim() : '';
                        console.log(`  Error message: "${errorText}"`);
                        
                        // Get label
                        let label = '';
                        const labelEl = fieldContainer.querySelector('label');
                        if (labelEl) {
                            label = labelEl.textContent.trim() || '';
                            console.log(`  Label: "${label}"`);
                        }
                        
                        // Find the actual input/select/textarea/radio in this container
                        // Try radio buttons first (they're in .radio-options)
                        let field = fieldContainer.querySelector('.radio-options input[type="radio"]');
                        let fieldName = '';
                        let fieldId = '';
                        let fieldType = '';
                        
                        if (field) {
                            fieldName = field.name || '';
                            fieldId = field.id || '';
                            fieldType = 'radio';
                            console.log(`  Found radio group: name="${fieldName}"`);
                            
                            // Verify there are multiple radios with this name
                            const radioGroup = document.querySelectorAll(`input[type="radio"][name="${fieldName}"]`);
                            if (radioGroup.length > 0) {
                                console.log(`  Confirmed: ${radioGroup.length} radio button(s) with this name`);
                                errors.push({
                                    errorText: errorText,
                                    fieldName: fieldName,
                                    fieldId: fieldId,
                                    fieldLabel: label,
                                    fieldPlaceholder: '',
                                    fieldType: 'radio',
                                    fieldValue: '',
                                    containerElement: true  // Mark that we found it in container
                                });
                            }
                        } else {
                            // Try other field types
                            field = fieldContainer.querySelector('input, select, textarea');
                            if (field) {
                                fieldName = field.name || '';
                                fieldId = field.id || '';
                                fieldType = field.type || field.tagName.toLowerCase();
                                console.log(`  Found ${fieldType} field: name="${fieldName}", id="${fieldId}"`);
                                
                                errors.push({
                                    errorText: errorText,
                                    fieldName: fieldName,
                                    fieldId: fieldId,
                                    fieldLabel: label,
                                    fieldPlaceholder: field.placeholder || '',
                                    fieldType: fieldType,
                                    fieldValue: field.value || '',
                                    containerElement: true
                                });
                            } else {
                                console.log(`  WARNING: No field found in container ${idx + 1}`);
                            }
                        }
                    });
                    
                    // Also check error selectors
                    errorSelectors.forEach(selector => {
                        document.querySelectorAll(selector).forEach(el => {
                            const style = window.getComputedStyle(el);
                            if (style.display !== 'none' && style.visibility !== 'hidden') {
                                const text = el.textContent?.trim() || '';
                                if (text.length > 0) {
                                    // Find associated field
                                    let field = null;
                                    let fieldName = '';
                                    let fieldId = '';
                                    let fieldLabel = '';
                                    let fieldPlaceholder = '';
                                    
                                    // Strategy 1: Check parent container
                                    const parent = el.closest('.form-group, .field, [class*="form"], .mb-3, .col-md-12, .col-md-6');
                                    if (parent) {
                                        field = parent.querySelector('input, select, textarea, .radio-options input[type="radio"]');
                                        if (field) {
                                            fieldName = field.name || '';
                                            fieldId = field.id || '';
                                            fieldPlaceholder = field.placeholder || '';
                                            
                                            // Get label
                                            const label = parent.querySelector('label');
                                            if (label) {
                                                fieldLabel = label.textContent?.trim() || '';
                                            }
                                        }
                                    }
                                    
                                    if (field) {
                                        const existing = errors.find(e => 
                                            (e.fieldName && e.fieldName === fieldName) || 
                                            (e.fieldId && e.fieldId === fieldId)
                                        );
                                        if (!existing) {
                                            errors.push({
                                                errorText: text,
                                                fieldName: fieldName,
                                                fieldId: fieldId,
                                                fieldLabel: fieldLabel,
                                                fieldPlaceholder: fieldPlaceholder,
                                                fieldType: field.type || field.tagName.toLowerCase(),
                                                fieldValue: field.value || ''
                                            });
                                        }
                                    }
                                }
                            }
                        });
                    });
                    
                    return errors;
                }
            """)
            
            print(f'[INFO] Step 1 complete: Found {len(error_data)} error(s) to fix')
            
            if error_data:
                print('[INFO] Error details:')
                for idx, error in enumerate(error_data, 1):
                    print(f'   Error {idx}:')
                    print(f'      Text: "{error.get("errorText", "")}"')
                    print(f'      Field Name: "{error.get("fieldName", "")}"')
                    print(f'      Field ID: "{error.get("fieldId", "")}"')
                    print(f'      Field Label: "{error.get("fieldLabel", "")}"')
                    print(f'      Field Type: "{error.get("fieldType", "")}"')
            else:
                print('[WARNING] No errors found! This might mean:')
                print('   1. Form was submitted successfully')
                print('   2. Errors are not being detected by our selectors')
                print('   3. Page structure is different than expected')
                
                # Try to find any visible error messages as a fallback
                print('\n[INFO] Trying fallback error detection...')
                fallback_errors = await self.page.evaluate("""
                    () => {
                        const allErrors = [];
                        // Find all elements with error-related text
                        const allElements = document.querySelectorAll('*');
                        allElements.forEach(el => {
                            const text = el.textContent || '';
                            const lowerText = text.toLowerCase();
                            if (lowerText.includes('muss angegeben werden') || 
                                lowerText.includes('required') || 
                                lowerText.includes('bitte') && lowerText.includes('auswählen')) {
                                const style = window.getComputedStyle(el);
                                if (style.display !== 'none' && style.visibility !== 'hidden') {
                                    allErrors.push({
                                        text: text.trim(),
                                        tagName: el.tagName,
                                        className: el.className
                                    });
                                }
                            }
                        });
                        return allErrors;
                    }
                """)
                
                if fallback_errors:
                    print(f'[INFO] Found {len(fallback_errors)} potential error(s) with fallback method:')
                    for err in fallback_errors[:5]:
                        print(f'   - {err.get("tagName")} ({err.get("className")}): "{err.get("text")[:100]}"')
                else:
                    print('[INFO] No errors found with fallback method either')
                
                return False
            
            if not error_data:
                return False
            
            # Step 2: Fix each error
            print(f'\n[INFO] Step 2: Attempting to fix {len(error_data)} error(s)...')
            fixed_count = 0
            fixed_field_ids = set()
            
            for idx, error in enumerate(error_data, 1):
                try:
                    # Skip if already fixed
                    field_id = error.get('fieldId') or error.get('fieldName')
                    if field_id and field_id in fixed_field_ids:
                        continue
                    
                    error_text = error.get('errorText', '')
                    field_name = error.get('fieldName', '')
                    field_id = error.get('fieldId', '')
                    field_label = error.get('fieldLabel', '')
                    field_placeholder = error.get('fieldPlaceholder', '')
                    field_type = error.get('fieldType', '')
                    
                    print(f'\n[INFO] --- Processing Error {idx}/{len(error_data)} ---')
                    print(f'[INFO] Error message: "{error_text}"')
                    print(f'[INFO] Field details:')
                    print(f'   - Name: "{field_name}"')
                    print(f'   - ID: "{field_id}"')
                    print(f'   - Label: "{field_label}"')
                    print(f'   - Type: "{field_type}"')
                    print(f'   - Placeholder: "{field_placeholder}"')
                    
                    # Create field info object for config matching
                    field_info = {
                        'name': field_name,
                        'id': field_id,
                        'label': field_label,
                        'placeholder': field_placeholder,
                        'type': field_type
                    }
                    
                    # Find config value for this field
                    print(f'[INFO] Looking up config value for this field...')
                    config_value = self._get_config_value_for_field(
                        field_info, personal_info, file_paths, questions, talent_pool
                    )
                    
                    if config_value is not None and config_value != '':
                        print(f'[OK] Found config value: "{config_value}"')
                        
                        # Find the field locator
                        print(f'[INFO] Locating field element...')
                        field_locator = None
                        
                        # For radio buttons, always use name selector (more reliable)
                        if field_type == 'radio' and field_name:
                            print(f'   [RADIO] Trying radio buttons by name: input[type="radio"][name="{field_name}"]')
                            field_locator = self.page.locator(f'input[type="radio"][name="{field_name}"]').first
                            count = await field_locator.count()
                            print(f'   [RADIO] Found {count} radio button(s) with this name')
                        elif field_id and field_type != 'radio':
                            # For non-radio fields, try ID first (but use attribute selector for special chars)
                            print(f'   Trying by ID: [id="{field_id}"]')
                            try:
                                field_locator = self.page.locator(f'[id="{field_id}"]').first
                                count = await field_locator.count()
                                print(f'   Found {count} element(s) by ID')
                            except Exception as e:
                                print(f'   [WARNING] Error with ID selector: {str(e)}')
                                field_locator = None
                        elif field_name:
                            # For other fields, use name selector
                            print(f'   Trying by name: [name="{field_name}"]')
                            field_locator = self.page.locator(f'[name="{field_name}"]').first
                            count = await field_locator.count()
                            print(f'   Found {count} element(s) by name')
                        
                        # Check if locator is valid and has elements
                        locator_valid = False
                        if field_locator:
                            try:
                                count = await field_locator.count()
                                locator_valid = count > 0
                            except Exception as e:
                                print(f'   [WARNING] Error checking locator count: {str(e)}')
                                locator_valid = False
                        
                        if locator_valid:
                            print(f'[OK] Field element found!')
                            field_info_full = await self._get_field_info(field_locator)
                            print(f'[INFO] Field info retrieved:')
                            print(f'   - Label: "{field_info_full.get("label", "")}"')
                            print(f'   - Name: "{field_info_full.get("name", "")}"')
                            print(f'   - Type: "{field_info_full.get("type", "")}"')
                            print(f'[INFO] Attempting to fill field...')
                            
                            # For radio buttons, pass the original locator and label
                            if field_type == 'radio':
                                print(f'[INFO] Using RadioFieldFiller for radio buttons...')
                                success = await RadioFieldFiller.fill(
                                    self.page, 
                                    f'input[type="radio"][name="{field_name}"]',
                                    str(config_value),
                                    field_name,
                                    field_label,
                                    field_locator
                                )
                                if success:
                                    print(f'[OK] Radio field filled successfully!')
                                else:
                                    print(f'[WARNING] Radio field fill failed')
                            else:
                                print(f'[INFO] Using _fill_field_by_info for non-radio field...')
                                success = await self._fill_field_by_info(field_locator, field_info_full, config_value)
                                if success:
                                    print(f'[OK] Field filled successfully!')
                                else:
                                    print(f'[WARNING] Field fill failed')
                            
                            if success:
                                fixed_count += 1
                                fixed_field_ids.add(field_id or field_name)
                                print(f'[OK] Error {idx} fixed! (Total fixed: {fixed_count})')
                                await self.page.wait_for_timeout(500)
                            else:
                                print(f'[WARNING] Failed to fix error {idx} with config value')
                                print(f'[INFO] Attempting interactive mode as fallback...')
                                
                                # Try interactive mode if config value didn't work
                                user_value = await self._ask_user_for_value(field_info_full, field_locator)
                                
                                if user_value:
                                    print(f'[INFO] User provided value: "{user_value}"')
                                    
                                    # Try to fill with user value
                                    if field_type == 'radio':
                                        success2 = await RadioFieldFiller.fill(
                                            self.page, 
                                            f'input[type="radio"][name="{field_name}"]',
                                            str(user_value),
                                            field_name,
                                            field_label,
                                            field_locator
                                        )
                                    else:
                                        success2 = await self._fill_field_by_info(field_locator, field_info_full, user_value)
                                    
                                    if success2:
                                        fixed_count += 1
                                        fixed_field_ids.add(field_id or field_name)
                                        print(f'[OK] Error {idx} fixed with user input!')
                                        await self.page.wait_for_timeout(500)
                                    else:
                                        print(f'[WARNING] Failed to fill field even with user input')
                                else:
                                    print(f'[SKIP] User skipped this field')
                        else:
                            print(f'[WARNING] Field not found by id/name')
                            print(f'   - Tried ID: {field_id}')
                            print(f'   - Tried Name: {field_name}')
                            print(f'   - Field Type: {field_type}')
                            
                            # Try to find the field with alternative methods
                            if field_name:
                                print(f'[INFO] Trying alternative selectors...')
                                
                                # For radio buttons, try to find the container first
                                if field_type == 'radio':
                                    print(f'[INFO] Looking for radio button container...')
                                    # Find the container with is-invalid class that contains this radio group
                                    container = await self.page.evaluate("""
                                        (name) => {
                                            const containers = document.querySelectorAll('.is-invalid, [class*="is-invalid"]');
                                            for (const container of containers) {
                                                const radio = container.querySelector(`input[type="radio"][name="${name}"]`);
                                                if (radio) {
                                                    return {
                                                        found: true,
                                                        containerClass: container.className,
                                                        label: container.querySelector('label')?.textContent?.trim() || ''
                                                    };
                                                }
                                            }
                                            return { found: false };
                                        }
                                    """, field_name)
                                    
                                    if container.get('found'):
                                        print(f'   Found container with label: "{container.get("label")}"')
                                
                                # Try to find all radio buttons with this name
                                all_radios = await self.page.locator(f'input[type="radio"][name="{field_name}"]').all()
                                print(f'   Found {len(all_radios)} radio button(s) with name="{field_name}"')
                                
                                if len(all_radios) > 0:
                                    print(f'[INFO] Found radio buttons, trying to fill...')
                                    # Get the first radio button as locator for context
                                    first_radio = all_radios[0]
                                    success = await RadioFieldFiller.fill(
                                        self.page, 
                                        f'input[type="radio"][name="{field_name}"]',
                                        str(config_value),
                                        field_name,
                                        field_label,
                                        first_radio
                                    )
                                    if success:
                                        fixed_count += 1
                                        fixed_field_ids.add(field_id or field_name)
                                        print(f'[OK] Error {idx} fixed with alternative method!')
                                    else:
                                        print(f'[WARNING] Radio fill failed even with alternative method')
                                else:
                                    print(f'[WARNING] No radio buttons found with name="{field_name}"')
                            else:
                                print(f'[WARNING] No field name available for alternative search')
                    else:
                        print(f'[WARNING] No config value found for this field')
                        print(f'   - Field Name: "{field_name}"')
                        print(f'   - Field Label: "{field_label}"')
                        print(f'   - Field ID: "{field_id}"')
                        print(f'   - Available in config:')
                        print(f'      - questions.german_level: {questions.get("german_level")}')
                        print(f'      - personal_info.german_knowledge: {personal_info.get("german_knowledge")}')
                        
                        # Try interactive mode for error recovery
                        print(f'\n[INFO] Attempting interactive mode for error recovery...')
                        
                        # Find the field locator first
                        field_locator = None
                        if field_type == 'radio' and field_name:
                            field_locator = self.page.locator(f'input[type="radio"][name="{field_name}"]').first
                        elif field_id:
                            try:
                                field_locator = self.page.locator(f'[id="{field_id}"]').first
                            except:
                                pass
                        elif field_name:
                            field_locator = self.page.locator(f'[name="{field_name}"]').first
                        
                        if field_locator and await field_locator.count() > 0:
                            field_info_full = await self._get_field_info(field_locator)
                            user_value = await self._ask_user_for_value(field_info_full, field_locator)
                            
                            if user_value:
                                print(f'[INFO] User provided value: "{user_value}"')
                                
                                # Try to fill with user value
                                if field_type == 'radio':
                                    success = await RadioFieldFiller.fill(
                                        self.page, 
                                        f'input[type="radio"][name="{field_name}"]',
                                        str(user_value),
                                        field_name,
                                        field_label,
                                        field_locator
                                    )
                                else:
                                    success = await self._fill_field_by_info(field_locator, field_info_full, user_value)
                                
                                if success:
                                    fixed_count += 1
                                    fixed_field_ids.add(field_id or field_name)
                                    print(f'[OK] Error {idx} fixed with user input!')
                                    await self.page.wait_for_timeout(500)
                                else:
                                    print(f'[WARNING] Failed to fill field even with user input')
                            else:
                                print(f'[SKIP] User skipped this field')
                        else:
                            print(f'[WARNING] Could not locate field for interactive mode')
                        
                except Exception as e:
                    print(f'   [ERROR] Error fixing field: {str(e)}')
                    continue
            
            if fixed_count > 0:
                print(f'\n[OK] Fixed {fixed_count} error(s)')
                await self.page.wait_for_timeout(1000)
                return True
            else:
                print('\n[WARNING] No errors were fixed')
                return False
                
        except Exception as e:
            print(f'[ERROR] Error in smart error recovery: {str(e)}')
            import traceback
            print(traceback.format_exc())
            return False

